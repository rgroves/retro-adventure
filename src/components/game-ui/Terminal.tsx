import { useEffect, useRef, useState } from "react";
import {
  Button,
  Flex,
  ScrollView,
  Text,
  useTheme,
  View,
} from "@aws-amplify/ui-react";
import { type Game } from "../../game/Game";
import TerminalInput from "./TerminalInput";

const TERMINAL_PADDING_WIDTH = 2;
const TERMINAL_BORDER_WIDTH = 1;
const TERMINAL_WIDTH =
  80 + TERMINAL_PADDING_WIDTH * 2 + TERMINAL_BORDER_WIDTH * 2;
const TERMINAL_HEIGHT = 25;
const EMPTY_TERMINAL_LINES = Array(TERMINAL_HEIGHT)
  .fill(undefined)
  .map(() => {
    return <Text key={crypto.randomUUID()}>&nbsp;</Text>;
  });

type TerminalProps = {
  game: Game;
};

export default function Terminal({ game }: TerminalProps) {
  const { tokens } = useTheme();
  const [terminalOutput, setTerminalOutput] = useState<JSX.Element[]>([]);
  const [playerPrompt, setPlayerPrompt] = useState("");
  const [power, setPower] = useState(false);

  /**
   * The gameOutputAdapater is responsible for recieving the output generated
   * by the Game engine and manipulating it so that it is properly renderable
   * in the Terminal, optionally clearing any previously received output.
   */
  function gameOutputAdapter(output: string[], clear: boolean) {
    const renderableOutput = [
      ...output.map((str) => (
        <Text key={crypto.randomUUID()}>{str ? str : <>&nbsp;</>}</Text>
      )),
    ];
    clear
      ? setTerminalOutput([...EMPTY_TERMINAL_LINES, ...renderableOutput])
      : setTerminalOutput((prev) => [
          ...prev,
          <hr key={crypto.randomUUID()} />,
          <br key={crypto.randomUUID()} />,
          ...renderableOutput,
        ]);
  }

  game.setOutputAdapter(gameOutputAdapter);

  /**
   * An explicit adapter for the player prompt is not needed since the prompt
   * text generated by the game engine is just used as the child value of the
   * last Text line in the Terminal output and doesn't need to be transformed or
   * wrapped by a JSX element.
   */
  game.setPlayerPromptAdapter(setPlayerPrompt);

  const terminalWindowRef = useRef<HTMLDivElement>(null);
  const playerPromptRef = useRef<HTMLParagraphElement>(null);

  useEffect(() => {
    if (playerPromptRef) {
      playerPromptRef.current?.scrollIntoView({ behavior: "smooth" });
    }
  }, [terminalOutput]);

  const powerHandler = () => {
    const value = !power;
    setPower(value);
    if (value) {
      terminalWindowRef.current?.scrollTo(0, 0);
      game.start();
    } else {
      setTerminalOutput([]);
      setPlayerPrompt("");
    }
  };

  return (
    <Flex justifyContent={"space-around"}>
      <View fontFamily="monospace" fontSize={tokens.fontSizes.medium} width={`${TERMINAL_WIDTH}ch`}>
        <Flex direction="column" gap="0" minHeight="100%">
          <ScrollView
            ref={terminalWindowRef}
            aria-readonly={true}
            style={{ overflowY: "hidden" }}
            border={`${TERMINAL_BORDER_WIDTH}ch ridge silver`}
            padding={`${TERMINAL_PADDING_WIDTH}ch`}
            height={`${TERMINAL_HEIGHT}lh`}
            minHeight={`${TERMINAL_HEIGHT}lh`}
          >
            {terminalOutput && terminalOutput.map((line) => line)}
            {playerPrompt && <Text ref={playerPromptRef}>{playerPrompt}</Text>}
          </ScrollView>
          <TerminalInput playerInputProcessor={game.processInput.bind(game)} />
          <Button
            alignSelf={"flex-end"}
            borderColor={power ? "green" : "red"}
            onClick={powerHandler}
            marginBlockStart={tokens.fontSizes.large}
          >
            Power [{power ? "On" : "Off"}]
          </Button>
        </Flex>
      </View>
    </Flex>
  );
}
